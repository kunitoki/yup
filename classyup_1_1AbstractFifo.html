<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YUP: yup::AbstractFifo Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">YUP
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<div id="main-nav">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- main-nav -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespaceyup.html">yup</a></li><li class="navelem"><a href="classyup_1_1AbstractFifo.html">AbstractFifo</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classyup_1_1AbstractFifo-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">yup::AbstractFifo Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Encapsulates the logic required to implement a lock-free FIFO.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:ScopedReadWrite" id="r_ScopedReadWrite"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyup_1_1AbstractFifo_1_1ScopedReadWrite.html">ScopedReadWrite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for a scoped reader/writer.  <a href="classyup_1_1AbstractFifo_1_1ScopedReadWrite.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a47cd2dce384ffd2f748722931c7611bc" id="r_a47cd2dce384ffd2f748722931c7611bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47cd2dce384ffd2f748722931c7611bc">ScopedRead</a> = <a class="el" href="classyup_1_1AbstractFifo_1_1ScopedReadWrite.html">ScopedReadWrite</a>&lt;ReadOrWrite::read&gt;</td></tr>
<tr class="memitem:a9ed7ddc423469971d974c3ea28c910a7" id="r_a9ed7ddc423469971d974c3ea28c910a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ed7ddc423469971d974c3ea28c910a7">ScopedWrite</a> = <a class="el" href="classyup_1_1AbstractFifo_1_1ScopedReadWrite.html">ScopedReadWrite</a>&lt;ReadOrWrite::write&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0483a1b8c8525f0805c9f0ae501bd570" id="r_a0483a1b8c8525f0805c9f0ae501bd570"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0483a1b8c8525f0805c9f0ae501bd570">AbstractFifo</a> (int capacity) noexcept</td></tr>
<tr class="memdesc:a0483a1b8c8525f0805c9f0ae501bd570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a FIFO to manage a buffer with the specified capacity.  <br /></td></tr>
<tr class="memitem:a9ceb9c41aaab2cd7fb9317ebce2a4e5c" id="r_a9ceb9c41aaab2cd7fb9317ebce2a4e5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ceb9c41aaab2cd7fb9317ebce2a4e5c">getTotalSize</a> () const noexcept</td></tr>
<tr class="memdesc:a9ceb9c41aaab2cd7fb9317ebce2a4e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total size of the buffer being managed.  <br /></td></tr>
<tr class="memitem:a9ed8bf85957e19739c94084ba5e329a4" id="r_a9ed8bf85957e19739c94084ba5e329a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ed8bf85957e19739c94084ba5e329a4">getFreeSpace</a> () const noexcept</td></tr>
<tr class="memdesc:a9ed8bf85957e19739c94084ba5e329a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items that can currently be added to the buffer without it overflowing.  <br /></td></tr>
<tr class="memitem:a052c48821a9c57a2a4c526fcb407e3e9" id="r_a052c48821a9c57a2a4c526fcb407e3e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a052c48821a9c57a2a4c526fcb407e3e9">getNumReady</a> () const noexcept</td></tr>
<tr class="memdesc:a052c48821a9c57a2a4c526fcb407e3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items that can currently be read from the buffer.  <br /></td></tr>
<tr class="memitem:ac83a1002b7a130476ed622daedc886b7" id="r_ac83a1002b7a130476ed622daedc886b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac83a1002b7a130476ed622daedc886b7">reset</a> () noexcept</td></tr>
<tr class="memdesc:ac83a1002b7a130476ed622daedc886b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the buffer positions, so that it appears empty.  <br /></td></tr>
<tr class="memitem:afd445ab62d38f1d879be7c6c72d630e9" id="r_afd445ab62d38f1d879be7c6c72d630e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd445ab62d38f1d879be7c6c72d630e9">setTotalSize</a> (int newSize) noexcept</td></tr>
<tr class="memdesc:afd445ab62d38f1d879be7c6c72d630e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the buffer's total size.  <br /></td></tr>
<tr class="memitem:a9d4281c70391342fe03874f908da250b" id="r_a9d4281c70391342fe03874f908da250b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d4281c70391342fe03874f908da250b">prepareToWrite</a> (int numToWrite, int &amp;startIndex1, int &amp;blockSize1, int &amp;startIndex2, int &amp;blockSize2) const noexcept</td></tr>
<tr class="memdesc:a9d4281c70391342fe03874f908da250b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the location within the buffer at which an incoming block of data should be written.  <br /></td></tr>
<tr class="memitem:a9e58116859a4b2d281b426ec7e7d11e9" id="r_a9e58116859a4b2d281b426ec7e7d11e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e58116859a4b2d281b426ec7e7d11e9">finishedWrite</a> (int numWritten) noexcept</td></tr>
<tr class="memdesc:a9e58116859a4b2d281b426ec7e7d11e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after writing from the FIFO, to indicate that this many items have been added.  <br /></td></tr>
<tr class="memitem:af8f9d697656bd06c120c2dff5196642a" id="r_af8f9d697656bd06c120c2dff5196642a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8f9d697656bd06c120c2dff5196642a">prepareToRead</a> (int numWanted, int &amp;startIndex1, int &amp;blockSize1, int &amp;startIndex2, int &amp;blockSize2) const noexcept</td></tr>
<tr class="memdesc:af8f9d697656bd06c120c2dff5196642a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the location within the buffer from which the next block of data should be read.  <br /></td></tr>
<tr class="memitem:a95ac6f5e2527913b26cf304793e65631" id="r_a95ac6f5e2527913b26cf304793e65631"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95ac6f5e2527913b26cf304793e65631">finishedRead</a> (int numRead) noexcept</td></tr>
<tr class="memdesc:a95ac6f5e2527913b26cf304793e65631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after reading from the FIFO, to indicate that this many items have now been consumed.  <br /></td></tr>
<tr class="memitem:ac206b80bfd9fa7c927e49fe4b9771193" id="r_ac206b80bfd9fa7c927e49fe4b9771193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a47cd2dce384ffd2f748722931c7611bc">ScopedRead</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac206b80bfd9fa7c927e49fe4b9771193">read</a> (int numToRead) noexcept</td></tr>
<tr class="memdesc:ac206b80bfd9fa7c927e49fe4b9771193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces prepareToRead/finishedRead with a single function.  <br /></td></tr>
<tr class="memitem:a404f76c2136d0729a2cb54ee5f5243d9" id="r_a404f76c2136d0729a2cb54ee5f5243d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9ed7ddc423469971d974c3ea28c910a7">ScopedWrite</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a404f76c2136d0729a2cb54ee5f5243d9">write</a> (int numToWrite) noexcept</td></tr>
<tr class="memdesc:a404f76c2136d0729a2cb54ee5f5243d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces prepareToWrite/finishedWrite with a single function.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates the logic required to implement a lock-free FIFO. </p>
<p>This class handles the logic needed when building a single-reader, single-writer FIFO.</p>
<p>It doesn't actually hold any data itself, but your FIFO class can use one of these to manage its position and status when reading or writing to it.</p>
<p>To use it, you can call <a class="el" href="#a9d4281c70391342fe03874f908da250b" title="Returns the location within the buffer at which an incoming block of data should be written.">prepareToWrite()</a> to determine the position within your own buffer that an incoming block of data should be stored, and <a class="el" href="#af8f9d697656bd06c120c2dff5196642a" title="Returns the location within the buffer from which the next block of data should be read.">prepareToRead()</a> to find out when the next outgoing block should be read from.</p>
<p>e.g. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyFifo</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> addToFifo (<span class="keyword">const</span> <span class="keywordtype">int</span>* someData, <span class="keywordtype">int</span> numItems)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> scope = abstractFifo.write (numItems);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (scope.blockSize1 &gt; 0)</div>
<div class="line">            copySomeData (myBuffer + scope.startIndex1, someData, scope.blockSize1);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (scope.blockSize2 &gt; 0)</div>
<div class="line">            copySomeData (myBuffer + scope.startIndex2, someData + scope.blockSize1, scope.blockSize2);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> readFromFifo (<span class="keywordtype">int</span>* someData, <span class="keywordtype">int</span> numItems)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> scope = abstractFifo.read (numItems);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (scope.blockSize1 &gt; 0)</div>
<div class="line">            copySomeData (someData, myBuffer + scope.startIndex1, scope.blockSize1);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (scope.blockSize2 &gt; 0)</div>
<div class="line">            copySomeData (someData + scope.blockSize1, myBuffer + scope.startIndex2, scope.blockSize2);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    AbstractFifo abstractFifo { 1024 };</div>
<div class="line">    <span class="keywordtype">int</span> myBuffer[1024];</div>
<div class="line">};</div>
</div><!-- fragment --> </div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a47cd2dce384ffd2f748722931c7611bc" name="a47cd2dce384ffd2f748722931c7611bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cd2dce384ffd2f748722931c7611bc">&#9670;&#160;</a></span>ScopedRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a47cd2dce384ffd2f748722931c7611bc">yup::AbstractFifo::ScopedRead</a> = <a class="el" href="classyup_1_1AbstractFifo_1_1ScopedReadWrite.html">ScopedReadWrite</a>&lt;ReadOrWrite::read&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ed7ddc423469971d974c3ea28c910a7" name="a9ed7ddc423469971d974c3ea28c910a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed7ddc423469971d974c3ea28c910a7">&#9670;&#160;</a></span>ScopedWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9ed7ddc423469971d974c3ea28c910a7">yup::AbstractFifo::ScopedWrite</a> = <a class="el" href="classyup_1_1AbstractFifo_1_1ScopedReadWrite.html">ScopedReadWrite</a>&lt;ReadOrWrite::write&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0483a1b8c8525f0805c9f0ae501bd570" name="a0483a1b8c8525f0805c9f0ae501bd570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0483a1b8c8525f0805c9f0ae501bd570">&#9670;&#160;</a></span>AbstractFifo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yup::AbstractFifo::AbstractFifo </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a FIFO to manage a buffer with the specified capacity. </p>

<p class="reference">Referenced by <a class="el" href="classyup_1_1AbstractFifo_1_1ScopedReadWrite.html#a010552f566e0ac4630a4bb7e256d99f6">yup::AbstractFifo::ScopedReadWrite&lt; ReadOrWrite::read &gt;::ScopedReadWrite()</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a9ceb9c41aaab2cd7fb9317ebce2a4e5c" name="a9ceb9c41aaab2cd7fb9317ebce2a4e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ceb9c41aaab2cd7fb9317ebce2a4e5c">&#9670;&#160;</a></span>getTotalSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int yup::AbstractFifo::getTotalSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total size of the buffer being managed. </p>

</div>
</div>
<a id="a9ed8bf85957e19739c94084ba5e329a4" name="a9ed8bf85957e19739c94084ba5e329a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed8bf85957e19739c94084ba5e329a4">&#9670;&#160;</a></span>getFreeSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int yup::AbstractFifo::getFreeSpace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of items that can currently be added to the buffer without it overflowing. </p>

<p class="reference">References <a class="el" href="#a052c48821a9c57a2a4c526fcb407e3e9">getNumReady()</a>.</p>

</div>
</div>
<a id="a052c48821a9c57a2a4c526fcb407e3e9" name="a052c48821a9c57a2a4c526fcb407e3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052c48821a9c57a2a4c526fcb407e3e9">&#9670;&#160;</a></span>getNumReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int yup::AbstractFifo::getNumReady </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of items that can currently be read from the buffer. </p>

<p class="reference">Referenced by <a class="el" href="#a9ed8bf85957e19739c94084ba5e329a4">getFreeSpace()</a>.</p>

</div>
</div>
<a id="ac83a1002b7a130476ed622daedc886b7" name="ac83a1002b7a130476ed622daedc886b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83a1002b7a130476ed622daedc886b7">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yup::AbstractFifo::reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the buffer positions, so that it appears empty. </p>

<p class="reference">Referenced by <a class="el" href="#afd445ab62d38f1d879be7c6c72d630e9">setTotalSize()</a>.</p>

</div>
</div>
<a id="afd445ab62d38f1d879be7c6c72d630e9" name="afd445ab62d38f1d879be7c6c72d630e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd445ab62d38f1d879be7c6c72d630e9">&#9670;&#160;</a></span>setTotalSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yup::AbstractFifo::setTotalSize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the buffer's total size. </p>
<p>Note that this isn't thread-safe, so don't call it if there's any danger that it might overlap with a call to any other method in this class! </p>

<p class="reference">References <a class="el" href="#ac83a1002b7a130476ed622daedc886b7">reset()</a>.</p>

</div>
</div>
<a id="a9d4281c70391342fe03874f908da250b" name="a9d4281c70391342fe03874f908da250b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4281c70391342fe03874f908da250b">&#9670;&#160;</a></span>prepareToWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yup::AbstractFifo::prepareToWrite </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numToWrite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>startIndex1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>blockSize1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>startIndex2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>blockSize2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the location within the buffer at which an incoming block of data should be written. </p>
<p>Because the section of data that you want to add to the buffer may overlap the end and wrap around to the start, two blocks within your buffer are returned, and you should copy your data into the first one, with any remaining data spilling over into the second.</p>
<p>If the number of items you ask for is too large to fit within the buffer's free space, then blockSize1 + blockSize2 may add up to a lower value than numToWrite. If this happens, you may decide to keep waiting and re-trying the method until there's enough space available.</p>
<p>After calling this method, if you choose to write your data into the blocks returned, you must call <a class="el" href="#a9e58116859a4b2d281b426ec7e7d11e9" title="Called after writing from the FIFO, to indicate that this many items have been added.">finishedWrite()</a> to tell the FIFO how much data you actually added.</p>
<p>e.g. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> addToFifo (<span class="keyword">const</span> <span class="keywordtype">int</span>* someData, <span class="keywordtype">int</span> numItems)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> start1, size1, start2, size2;</div>
<div class="line">    <a class="code hl_function" href="#a9d4281c70391342fe03874f908da250b">prepareToWrite</a> (numItems, start1, size1, start2, size2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (size1 &gt; 0)</div>
<div class="line">        copySomeData (myBuffer + start1, someData, size1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (size2 &gt; 0)</div>
<div class="line">        copySomeData (myBuffer + start2, someData + size1, size2);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="#a9e58116859a4b2d281b426ec7e7d11e9">finishedWrite</a> (size1 + size2);</div>
<div class="line">}</div>
<div class="ttc" id="aclassyup_1_1AbstractFifo_html_a9d4281c70391342fe03874f908da250b"><div class="ttname"><a href="#a9d4281c70391342fe03874f908da250b">yup::AbstractFifo::prepareToWrite</a></div><div class="ttdeci">void prepareToWrite(int numToWrite, int &amp;startIndex1, int &amp;blockSize1, int &amp;startIndex2, int &amp;blockSize2) const noexcept</div><div class="ttdoc">Returns the location within the buffer at which an incoming block of data should be written.</div><div class="ttdef"><b>Definition</b> yup_AbstractFifo.cpp:74</div></div>
<div class="ttc" id="aclassyup_1_1AbstractFifo_html_a9e58116859a4b2d281b426ec7e7d11e9"><div class="ttname"><a href="#a9e58116859a4b2d281b426ec7e7d11e9">yup::AbstractFifo::finishedWrite</a></div><div class="ttdeci">void finishedWrite(int numWritten) noexcept</div><div class="ttdoc">Called after writing from the FIFO, to indicate that this many items have been added.</div><div class="ttdef"><b>Definition</b> yup_AbstractFifo.cpp:99</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numToWrite</td><td>indicates how many items you'd like to add to the buffer </td></tr>
    <tr><td class="paramname">startIndex1</td><td>on exit, this will contain the start index in your buffer at which your data should be written </td></tr>
    <tr><td class="paramname">blockSize1</td><td>on exit, this indicates how many items can be written to the block starting at startIndex1 </td></tr>
    <tr><td class="paramname">startIndex2</td><td>on exit, this will contain the start index in your buffer at which any data that didn't fit into the first block should be written </td></tr>
    <tr><td class="paramname">blockSize2</td><td>on exit, this indicates how many items can be written to the block starting at startIndex2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9e58116859a4b2d281b426ec7e7d11e9" title="Called after writing from the FIFO, to indicate that this many items have been added.">finishedWrite</a> </dd></dl>

<p class="reference">References <a class="el" href="namespaceyup.html#a742ec791d91ff5c86efb0a4735d598f4">yup::jmin()</a>.</p>

</div>
</div>
<a id="a9e58116859a4b2d281b426ec7e7d11e9" name="a9e58116859a4b2d281b426ec7e7d11e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e58116859a4b2d281b426ec7e7d11e9">&#9670;&#160;</a></span>finishedWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yup::AbstractFifo::finishedWrite </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numWritten</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after writing from the FIFO, to indicate that this many items have been added. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9d4281c70391342fe03874f908da250b" title="Returns the location within the buffer at which an incoming block of data should be written.">prepareToWrite</a> </dd></dl>

</div>
</div>
<a id="af8f9d697656bd06c120c2dff5196642a" name="af8f9d697656bd06c120c2dff5196642a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f9d697656bd06c120c2dff5196642a">&#9670;&#160;</a></span>prepareToRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yup::AbstractFifo::prepareToRead </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numWanted</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>startIndex1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>blockSize1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>startIndex2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>blockSize2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the location within the buffer from which the next block of data should be read. </p>
<p>Because the section of data that you want to read from the buffer may overlap the end and wrap around to the start, two blocks within your buffer are returned, and you should read from both of them.</p>
<p>If the number of items you ask for is greater than the amount of data available, then blockSize1 + blockSize2 may add up to a lower value than numWanted. If this happens, you may decide to keep waiting and re-trying the method until there's enough data available.</p>
<p>After calling this method, if you choose to read the data, you must call <a class="el" href="#a95ac6f5e2527913b26cf304793e65631" title="Called after reading from the FIFO, to indicate that this many items have now been consumed.">finishedRead()</a> to tell the FIFO how much data you have consumed.</p>
<p>e.g. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> readFromFifo (<span class="keywordtype">int</span>* someData, <span class="keywordtype">int</span> numItems)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> start1, size1, start2, size2;</div>
<div class="line">    <a class="code hl_function" href="#af8f9d697656bd06c120c2dff5196642a">prepareToRead</a> (numSamples, start1, size1, start2, size2);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (size1 &gt; 0)</div>
<div class="line">        copySomeData (someData, myBuffer + start1, size1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (size2 &gt; 0)</div>
<div class="line">        copySomeData (someData + size1, myBuffer + start2, size2);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="#a95ac6f5e2527913b26cf304793e65631">finishedRead</a> (size1 + size2);</div>
<div class="line">}</div>
<div class="ttc" id="aclassyup_1_1AbstractFifo_html_a95ac6f5e2527913b26cf304793e65631"><div class="ttname"><a href="#a95ac6f5e2527913b26cf304793e65631">yup::AbstractFifo::finishedRead</a></div><div class="ttdeci">void finishedRead(int numRead) noexcept</div><div class="ttdoc">Called after reading from the FIFO, to indicate that this many items have now been consumed.</div><div class="ttdef"><b>Definition</b> yup_AbstractFifo.cpp:136</div></div>
<div class="ttc" id="aclassyup_1_1AbstractFifo_html_af8f9d697656bd06c120c2dff5196642a"><div class="ttname"><a href="#af8f9d697656bd06c120c2dff5196642a">yup::AbstractFifo::prepareToRead</a></div><div class="ttdeci">void prepareToRead(int numWanted, int &amp;startIndex1, int &amp;blockSize1, int &amp;startIndex2, int &amp;blockSize2) const noexcept</div><div class="ttdoc">Returns the location within the buffer from which the next block of data should be read.</div><div class="ttdef"><b>Definition</b> yup_AbstractFifo.cpp:111</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numWanted</td><td>indicates how many items you'd like to read from the buffer </td></tr>
    <tr><td class="paramname">startIndex1</td><td>on exit, this will contain the start index in your buffer at which your data should be written </td></tr>
    <tr><td class="paramname">blockSize1</td><td>on exit, this indicates how many items can be written to the block starting at startIndex1 </td></tr>
    <tr><td class="paramname">startIndex2</td><td>on exit, this will contain the start index in your buffer at which any data that didn't fit into the first block should be written </td></tr>
    <tr><td class="paramname">blockSize2</td><td>on exit, this indicates how many items can be written to the block starting at startIndex2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a95ac6f5e2527913b26cf304793e65631" title="Called after reading from the FIFO, to indicate that this many items have now been consumed.">finishedRead</a> </dd></dl>

<p class="reference">References <a class="el" href="namespaceyup.html#a742ec791d91ff5c86efb0a4735d598f4">yup::jmin()</a>.</p>

</div>
</div>
<a id="a95ac6f5e2527913b26cf304793e65631" name="a95ac6f5e2527913b26cf304793e65631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ac6f5e2527913b26cf304793e65631">&#9670;&#160;</a></span>finishedRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yup::AbstractFifo::finishedRead </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numRead</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after reading from the FIFO, to indicate that this many items have now been consumed. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af8f9d697656bd06c120c2dff5196642a" title="Returns the location within the buffer from which the next block of data should be read.">prepareToRead</a> </dd></dl>

</div>
</div>
<a id="ac206b80bfd9fa7c927e49fe4b9771193" name="ac206b80bfd9fa7c927e49fe4b9771193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac206b80bfd9fa7c927e49fe4b9771193">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a47cd2dce384ffd2f748722931c7611bc">AbstractFifo::ScopedRead</a> yup::AbstractFifo::read </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numToRead</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces prepareToRead/finishedRead with a single function. </p>
<p>This function returns an object which contains the start indices and block sizes, and also automatically finishes the read operation when it goes out of scope. </p><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> readHandle = fifo.read (4);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i != readHandle.blockSize1; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// read the item at index readHandle.startIndex1 + i</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i != readHandle.blockSize2; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// read the item at index readHandle.startIndex2 + i</span></div>
<div class="line">    }</div>
<div class="line">} <span class="comment">// readHandle goes out of scope here, finishing the read operation</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a404f76c2136d0729a2cb54ee5f5243d9" name="a404f76c2136d0729a2cb54ee5f5243d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404f76c2136d0729a2cb54ee5f5243d9">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9ed7ddc423469971d974c3ea28c910a7">AbstractFifo::ScopedWrite</a> yup::AbstractFifo::write </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numToWrite</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces prepareToWrite/finishedWrite with a single function. </p>
<p>This function returns an object which contains the start indices and block sizes, and also automatically finishes the write operation when it goes out of scope. </p><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> writeHandle = fifo.write (5);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i != writeHandle.blockSize1; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// write the item at index writeHandle.startIndex1 + i</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i != writeHandle.blockSize2; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// write the item at index writeHandle.startIndex2 + i</span></div>
<div class="line">    }</div>
<div class="line">} <span class="comment">// writeHandle goes out of scope here, finishing the write operation</span></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
